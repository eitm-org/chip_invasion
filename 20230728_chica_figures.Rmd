---
title: "20230728_chica_figures"
author: "Elizabeth Elton"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

source('chip_invasion/functions.R', local=TRUE)
library(spam64)
options(spam.force64 = TRUE)
```

```{r}
cute_surface_maker_newbie <- function(huvec_list, fit_list, chip_in, bottom_gfp_df) {
 # browser()
  x_seq <- seq(0, max(huvec_list[[chip_in]]$position_x), len = 100)
  y_seq <- seq(0, max(huvec_list[[chip_in]]$position_y), len = 100)  
  
  pos_grid <- expand.grid(x=x_seq, y=y_seq)
  
  #position_grid <- as.data.frame(x=huvec_list[[chip]]$position_x, y=huvec_list[[chip]]$position_y)
  
  fit_matrix <- matrix(predict(fit_list[[chip_in]], pos_grid), 100, 100) #this is not the same z as for the actual boundary bc it is based on the transformed x/y -- how can i use the actual values??
  
  chip_used <- bottom_gfp_df %>% filter(chip == chip_in)
  
  pos_x <- chip_used$position_x
  new_x <- ((chip_used$position_x + abs(min(chip_used$position_x))) * (100/(abs(min(chip_used$position_x)) + max(chip_used$position_x))))  #need to make generalizable to any chip if this works
  pos_y <- chip_used$position_y
  new_y <- ((chip_used$position_y + abs(min(chip_used$position_y))) * (100/(abs(min(chip_used$position_y)) + max(chip_used$position_y)))) 
  pos_z <- chip_used$centroid_z
  
  plot_ly(z=fit_matrix, colors = "plasma") %>% 
    add_surface(contours = list(
    z = list(
      show=TRUE,
      usecolormap=TRUE,
      highlightcolor="#406605",
      project=list(z=TRUE), line = list(smoothing = 0.85)
      )
    )) %>%
    add_trace(inherit = F, type = "scatter3d", mode="markers", x=new_x, y=new_y, z = pos_z,
              marker = list(color = '#0571b0')) %>% layout(
    scene = list(
      xaxis = list(nticks = 20),
      zaxis = list(nticks = 10),
      camera = list(eye = list(x = 0, y = -1, z = 0.5)), 
      aspectratio = list(x = 0.9, y = .8, z = 0.5))) %>%
    layout(title = "Object quantification using topographical surface method")
  
  #return(cute_surface)
  
} #TO DO: integrate into app UI
```

```{r}
us_og_data <- endothelial_epithelial_reader("/Users/eelton/Dropbox (EITM)/CLS Files Share with Elizabeth 2023/US-GFP Organoids CLS Analysis/20230219exp_D6_Chip1-6_invasion_US-GFP ORGS.xlsx")

test_data <- endothelial_epithelial_reader("chip_invasion/tests/testthat/test_endo.xlsx")

huvecs <- us_og_data$huvec_df
us_orgs <- us_og_data$organoid_df

#diagnostic_plots_ee(huvecs, us_orgs)

endoz <- endo_boundzer(huvecs, us_orgs)

the_counts <- epi_count(endoz$org_fits_df)

the_counts$gfp_per_chip_bottom

chip1 <- the_counts$all_gfp_bottom %>% filter(chip == 1)
```


```{r}
cute_surface_maker_newbie(endoz$huvec_list, endoz$fit_list, chip_in = 5, bottom_gfp_df = the_counts$all_gfp_bottom)
```
# yay!!!!!
# so now i need to do this but with a flat surface which *should* be easier
#need to get the mean z-height of the huvecs
#then plot as a surface

#mean chip3 huvec height:
```{r}
chip3_huvecs <- huvecs %>% filter(chip == 5)
mean_z <- mean(chip3_huvecs$centroid_z) # ~120
```



```{r}
chip3 <- the_counts$all_gfp_bottom %>% filter(chip == 5)

  new_x3 <- ((chip3$position_x + abs(min(chip3$position_x))) * (100/(abs(min(chip3$position_x)) + max(chip3$position_x))))  
  new_y3 <- ((chip3$position_y + abs(min(chip3$position_y))) * (100/(abs(min(chip3$position_y)) + max(chip3$position_y)))) 
  
zmatrix <- matrix(data = mean_z, nrow=100, ncol = 100)
  
  plot_ly(z=zmatrix, colors = "plasma") %>% 
    add_surface() %>%
    add_trace(type = "scatter3d", mode="markers", x=new_x3, y=new_y3, z = chip3$centroid_z) #oh wait this isnt quite right, i need to filter based on this boundary? maybe this chip isnt that great of an example bc its p flat
```

#flat filtered
```{r}
chip3_flat <- us_orgs %>% 
  filter(chip == 5,
         centroid_z < mean_z)

  flat_x3 <- ((chip3_flat$position_x + abs(min(chip3_flat$position_x))) * (100/(abs(min(chip3_flat$position_x)) + max(chip3_flat$position_x))))  
  flat_y3 <- ((chip3_flat$position_y + abs(min(chip3_flat$position_y))) * (100/(abs(min(chip3_flat$position_y)) + max(chip3_flat$position_y)))) 

plot_ly(z=zmatrix, colors = "plasma") %>% 
    add_surface() %>%
    add_trace(type = "scatter3d", mode="markers", x=flat_x3, y=flat_y3, z = chip3_flat$centroid_z) #oh see what would be realllly sick is if i could label the objects that r missing in a different color... or is that overkill
#stick w this for now and see what naim & co think
```

#remaking plots but with kimya data
  #topo surface plot - omg would be cute if i could make it match colors with the wiggles plot (plasma instead of viridis?)
  #3d wiggles plot
  #3d flat plot
  
  #why will this not just work please work 
  
#ideally also getting counts w both methods on multiple chips and making a table
```{r}
# kimya_data <- endothelial_epithelial_reader("/Users/eelton/Documents/chip_invasion/20220523exp_D6_Chips3,4,7,8_Analysis.xlsx")
# kimya.d10 <- endothelial_epithelial_reader("/Users/eelton/Documents/chip_invasion/20220316exp_D10_Chips5-10_Analysis.xlsx")
kimya.test <- endothelial_epithelial_reader("/Users/eelton/Documents/chip_invasion/20220316exp_D6_Chips5-10_Analysis.xlsx")
#kimya.huvecs <- kimya.test$huvec_df %>% dplyr::rename("centroid_z" = "huvec_population_huvec_plane_centroid_z") %>% filter(centroid_z > mean(centroid_z))
#kimya.orgs <- kimya.test$organoid_df %>% dplyr::rename("centroid_z" = "organoids_selected_image_region_centroid_z")
diagnostic_plots_ee(huvec_df = kimya.test$huvec_df, organoid_df = kimya.test$organoid_df)
```


```{r}
kimya.test.bound <- endo_boundzer(kimya.test$huvec_df, kimya.test$organoid_df) #like 15 min?

kimya.counts <- epi_count(kimya.test.bound$org_fits_df)

kimya.counts$gfp_per_chip_bottom #hmmmmmm

kimya.gfps.newchip <- kimya.counts$all_gfp_bottom %>%
  mutate(chip = case_when(chip == '5' ~ '1',
                          chip == '6' ~ '2',
                          chip == '7' ~ '3',
                          chip == '8' ~ '4',
                          chip == '9' ~ '5',
                          chip == '10' ~ '6',))
```


```{r}
surface(kimya.test.bound$fit_list$`8`, col = plasma(256))
```

```{r}
cute_surface_maker_newbie(kimya.test.bound$huvec_list, kimya.test.bound$fit_list, chip_in = 4, bottom_gfp_df = kimya.gfps.newchip)
```

sooo maybe chip 8 is the one to go with? need to see if i can make things smoother somehow -- lambda parameter in tps?


```{r}
# kimya6 <- kimya.test$huvec_df %>% filter(chip == "6")
# kimya.nah <- kimya.huvecs %>% filter(chip == "1")
# kimyad10.5 <- kimya.d10$huvec_df %>% filter(chip == "10")

kimya.chip8 <- kimya.test$huvec_df %>% dplyr::filter(chip == "8")

kimya.8.fit <- fastTps(x=kimya.chip8[, c("position_x", "position_y")], Y=kimya.chip8$centroid_z, aRange = 50, lambda = 3) 

#summary(kimya.test.bound$fit_list$`10`)

surface(kimya.8.fit, col = inferno(100))

whatareyou <- predictSE(kimya.8.fit)
curious <- kimya.8.fit$fitted.values + qnorm(0.975)*whatareyou
```

```{r}
 x_seq <- seq(0, max(kimya.chip8$position_x), len = 100)
  y_seq <- seq(0, max(kimya.chip8$position_y), len = 100)  
  
  pos_grid <- expand.grid(x=x_seq, y=y_seq)
  
  fit_matrix <- matrix(predict(kimya.8.fit, pos_grid), 100, 100)
  
  plot_ly(z=fit_matrix, colors = "inferno") %>% 
    add_surface() %>% layout(
    scene = list(
      xaxis = list(nticks = 20),
      zaxis = list(nticks = 10),
      camera = list(eye = list(x = 0, y = -1, z = 0.5)), 
      aspectratio = list(x = 0.9, y = .8, z = 0.3)))
```

#ok so todo:
  #redo endo boundzer for these chips, with a specific lambda
  #try plotting/filtering w newbie surface maker

```{r}
endo_boundzer_smooth <- function(huvec_df, organoid_df) {
 # browser()
  endo_chip_list <- split(huvec_df, f=huvec_df$chip)
  epi_chip_list <- split(organoid_df, f=organoid_df$chip)
  
  org_positions <- lapply(epi_chip_list, function(x) dplyr::select(x, position_x, position_y))
  
  endo_fits <- lapply(endo_chip_list, function(x) fastTps(x[, c("position_x", "position_y")], Y=x$centroid_z, aRange = 50, lambda = 3)) 
  
  se_endo_fits <- lapply(endo_fits, function(x) predictSE(x))
  avg_se_fits <- lapply(se_endo_fits, function(x) mean(x)*qnorm(0.975)) #top half of the ci around the fitted surface
  ses_together <- bind_rows(avg_se_fits) %>%
    pivot_longer(cols = everything(), names_to = "chip", values_to = "se") %>% #damn it
    mutate(chip = as.double(chip))
  
  #preds_w_se <- map2(.x=endo_fits, .y=avg_se_fits, ~.x+.y)
  
  #pred_fits <- map2(.x=preds_w_se, .y=org_positions, ~predict(.x, .y))
  pred_fits <- map2(.x=endo_fits, .y=org_positions, ~predict(.x, .y))
  org_fits <- map2(.x=epi_chip_list, .y=pred_fits, ~cbind(.x, .y))
  org_fits_clean <- lapply(org_fits, function(x) rename(x, "gfp_pred"=.y))
  
  ## split off here in some way
  org_fits_joined <- bind_rows(org_fits_clean) %>% 
    left_join(ses_together, by="chip") #%>%
  # group_by(chip) %>%
  # mutate(below_pred = centroid_z < (gfp_pred+se)) %>%
  # filter(below_pred == TRUE)
  
  #todo: make a summry table of zheights? idk how that would work here
  
  stuff_to_return <- list("huvec_list" = endo_chip_list, 
                          "org_list" = epi_chip_list, 
                          "fit_list" = endo_fits, 
                          "org_fits_df" = org_fits_joined)
  
  return(stuff_to_return)
}

chip8_gfps <- kimya.test$organoid_df %>% filter(chip == 8)
kimya.smooth.boundz <- endo_boundzer_smooth(kimya.test$huvec_df, kimya.test$organoid_df)
kimya.se.test8 <- endo_boundzer_smooth(chip8_huvecs, chip8_gfps)

kimya.smooth.count <- epi_count(kimya.smooth.boundz$org_fits_df)

kimya.smooth.count$gfp_per_chip_bottom #sliiightly diff but not by that much so im ok w it
kimya.smooth.gfps <- kimya.smooth.count$all_gfp_bottom %>%
  mutate(chip = case_when(chip == '5' ~ '1',
                          chip == '6' ~ '2',
                          chip == '7' ~ '3',
                          chip == '8' ~ '4',
                          chip == '9' ~ '5',
                          chip == '10' ~ '6'))
  
cute_surface_maker_newbie(kimya.smooth.boundz$huvec_list, kimya.smooth.boundz$fit_list, chip_in = 4, bottom_gfp_df = kimya.smooth.gfps) #something is going on w chip 9
```

#mean chip8 huvec height:
```{r}
chip8_huvecs <- kimya.test$huvec_df %>% filter(chip == 8)
mean_z8 <- mean(chip8_huvecs$centroid_z) # ~105
se_z8 <- danGoat::sem(chip8_huvecs$centroid_z)
ci_z8 <- se_z8*qnorm(0.975)

chip8 <- kimya.smooth.count$all_gfp_bottom %>% filter(chip == 8)


  
 #28!!!!! that's less!!!

  new_x8 <- ((chip8$position_x + abs(min(chip8$position_x))) * (80/(abs(min(chip8$position_x)) + max(chip3$position_x))))  
  new_y8 <- ((chip8$position_y + abs(min(chip8$position_y))) * (80/(abs(min(chip8$position_y)) + max(chip8$position_y)))) 
  
chip8_below_mean <- chip8 %>% 
  mutate(height = case_when(centroid_z < mean_z8 ~ "below",
                            centroid_z > mean_z8 ~ "above"),
         colors = case_when(centroid_z < mean_z8 ~ '#0571b0',
                            centroid_z > mean_z8 ~ "#FF9800"),
         x = ((chip8$position_x + abs(min(chip8$position_x))) * (80/(abs(min(chip8$position_x)) + max(chip3$position_x)))),
         y = ((chip8$position_y + abs(min(chip8$position_y))) * (80/(abs(min(chip8$position_y)) + max(chip8$position_y)))),
         z=centroid_z)
  
zmatrix <- matrix(data = mean_z8, nrow=100, ncol = 100)

# color_mapping <- c("above" = "#ca0020",
#                            "below" =  '#0571b0')

  plot_ly() %>% 
    add_surface(z=zmatrix, colors = "plasma", opacity = 0.8, showlegend = FALSE) %>%
    # add_markers(
    #    x=new_x8, y=new_y8, z = chip8_below_mean$centroid_z,
    #    text=~chip8_below_mean$height, name=~chip8_below_mean$height,
    #    marker = list(opacity=0.6, symbol=105, size=7, color=~color_mapping)
    # ) %>%
    add_trace(type = "scatter3d", mode="markers",
              data = chip8_below_mean, 
              x=~x, y=~y, z = ~z,
             # name = ~height,
              #color = ~height,
              #colors = ~colors,
              marker = list(color = chip8_below_mean$colors,
                            name = chip8_below_mean$height)
              ) %>%
    layout(
      title = list(text = "Object quanitification using flat line method", xanchor = 'center', yanchor = 'top'),
      #xaxis = list(title = "X"),
      #yaxis = list(title = "Y"),
    scene = list(
      xaxis = list(nticks = 20),
      zaxis = list(nticks = 10),
      camera = list(eye = list(x = 0, y = -1, z = 0.5)), 
      aspectratio = list(x = 0.9, y = .8, z = 0.5)))
  

```

#get the counts from kimya data using the mean height
```{r}
#get all the huvecs
#get their mean heights
#filter chips by mean height
#count

huvec_heights <- kimya.test$huvec_df %>%
  group_by(chip) %>%
  mutate(bound_z = mean(centroid_z)) %>%
  distinct(chip, bound_z)

orgs_w_height <- left_join(kimya.test$organoid_df, huvec_heights, by = "chip") %>%
  mutate(height = case_when(centroid_z < bound_z ~ "below",
                            centroid_z > bound_z ~ "above"))

counted_orgs <- orgs_w_height %>%
  filter(height == "below") %>%
  group_by(compound, chip) %>%
  summarise(gfp_in_bottom_channel = n()) %>%
  arrange(chip)
counted_orgs #nice!
  
```






```{r}
kimya.fit <- fastTps(x=kimya.nah[, c("position_x", "position_y")], Y=kimya.nah$centroid_z, aRange = 50) 
kimya.fit.slow <- spatialProcess(x=kimya1[, c("position_x", "position_y")], y=chip1$centroid_z) #do just for best one?

#summary(new.fit)

#surface(kimya.fit) #that is very regular... interesting... i dont like it
surface(kimya.fit, col = plasma(256)) #okie well matching xolor palette is v cute
#so far winner is day 10 #6 bc tilt is present
#d10 8 is also ok?
#test kimya 6 is kinda ok?? surprising
```



